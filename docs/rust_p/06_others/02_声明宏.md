# Rust 声明宏（Declarative Macros）

## 什么是声明宏

**声明宏**（Declarative Macros），也叫 **macro_rules! 宏**，是 Rust 中基于模式匹配的宏系统。它通过匹配代码模式来生成代码。

## 基本语法

```rust
macro_rules! 宏名称 {
    (模式1) => {
        生成的代码1
    };
    (模式2) => {
        生成的代码2
    };
    // 可以有多个分支...
}
```

## 简单例子

### 例子 1：无参数宏

```rust
macro_rules! say_hello {
    () => {
        println!("你好，世界！");
    };
}

fn main() {
    say_hello!();  // 输出: 你好，世界！
}
```

### 例子 2：带参数的宏

```rust
macro_rules! greet {
    ($name:expr) => {
        println!("你好, {}!", $name);
    };
}

fn main() {
    greet!("Alice");      // 你好, Alice!
    greet!("Bob");        // 你好, Bob!
    let name = "Charlie";
    greet!(name);         // 你好, Charlie!
}
```

### 例子 3：多个参数

```rust
macro_rules! create_point {
    ($x:expr, $y:expr) => {
        Point { x: $x, y: $y }
    };
}

struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p1 = create_point!(10, 20);
    let p2 = create_point!(5 + 5, 10 * 2);
    println!("p1: ({}, {})", p1.x, p1.y);
}
```

## 模式匹配标识符

| 标识符 | 说明 | 示例 |
|--------|------|------|
| `expr` | 表达式 | `1 + 2`, `foo()`, `x` |
| `ident` | 标识符 | 变量名、函数名、类型名 |
| `ty` | 类型 | `i32`, `String`, `Vec<T>` |
| `path` | 路径 | `std::io::Error` |
| `pat` | 模式 | `Some(x)`, `_`, `0..=10` |
| `stmt` | 语句 | `let x = 5;` |
| `block` | 代码块 | `{ ... }` |
| `item` | 项 | 函数、结构体、trait 等 |
| `meta` | 元数据 | `#[derive(Debug)]` |
| `tt` | 单个语法树 | 任何单个 token |
| `literal` | 字面量 | `42`, `"hello"`, `true` |

### 使用不同标识符的例子

```rust
// expr - 表达式
macro_rules! add {
    ($a:expr, $b:expr) => {
        $a + $b
    };
}

// ident - 标识符（如函数名）
macro_rules! create_function {
    ($func_name:ident) => {
        fn $func_name() {
            println!("函数 {} 被调用了", stringify!($func_name));
        }
    };
}

// ty - 类型
macro_rules! create_struct {
    ($name:ident, $field_type:ty) => {
        struct $name {
            value: $field_type,
        }
    };
}

fn main() {
    // 使用 add 宏
    let sum = add!(5, 10);
    println!("sum: {}", sum);
    
    // 使用 create_function 宏
    create_function!(hello);
    hello();
    
    // 使用 create_struct 宏
    create_struct!(Container, i32);
    let c = Container { value: 42 };
}
```

## 重复模式

使用 `$(...)*` 或 `$(...)+ ` 处理可变数量的参数。

### 零次或多次 `$(...)*`

```rust
// 标准库的 vec! 宏简化版
macro_rules! my_vec {
    ( $( $x:expr ),* ) => {
        {
            let mut temp_vec = Vec::new();
            $(
                temp_vec.push($x);
            )*
            temp_vec
        }
    };
}

fn main() {
    let v1 = my_vec![1, 2, 3, 4, 5];
    let v2 = my_vec![];  // 空向量也可以
    let v3 = my_vec![10];
    
    println!("{:?}", v1);  // [1, 2, 3, 4, 5]
}
```

### 一次或多次 `$(...)+`

```rust
macro_rules! print_all {
    ( $( $x:expr ),+ ) => {
        $(
            println!("{}", $x);
        )+
    };
}

fn main() {
    print_all!(1, 2, 3);
    // 输出:
    // 1
    // 2
    // 3
    
    // print_all!();  // 错误！至少需要一个参数
}
```

## 多分支模式

```rust
macro_rules! calculate {
    // 加法
    (add $a:expr, $b:expr) => {
        $a + $b
    };
    
    // 减法
    (sub $a:expr, $b:expr) => {
        $a - $b
    };
    
    // 乘法
    (mul $a:expr, $b:expr) => {
        $a * $b
    };
    
    // 除法
    (div $a:expr, $b:expr) => {
        $a / $b
    };
}

fn main() {
    println!("10 + 5 = {}", calculate!(add 10, 5));   // 15
    println!("10 - 5 = {}", calculate!(sub 10, 5));   // 5
    println!("10 * 5 = {}", calculate!(mul 10, 5));   // 50
    println!("10 / 5 = {}", calculate!(div 10, 5));   // 2
}
```

## 实用宏例子

### 1. HashMap 字面量

```rust
macro_rules! hashmap {
    ( $( $key:expr => $val:expr ),* ) => {
        {
            let mut map = ::std::collections::HashMap::new();
            $(
                map.insert($key, $val);
            )*
            map
        }
    };
}

fn main() {
    let map = hashmap! {
        "name" => "Alice",
        "age" => "30",
        "city" => "Beijing"
    };
    
    println!("{:?}", map);
}
```

### 2. 测试用例生成器

```rust
macro_rules! test_case {
    ($name:ident: $input:expr => $expected:expr) => {
        #[test]
        fn $name() {
            assert_eq!(double($input), $expected);
        }
    };
}

fn double(x: i32) -> i32 {
    x * 2
}

// 生成多个测试
test_case!(test_zero: 0 => 0);
test_case!(test_positive: 5 => 10);
test_case!(test_negative: -3 => -6);
```

### 3. 条件日志宏

```rust
macro_rules! log_debug {
    ($($arg:tt)*) => {
        #[cfg(debug_assertions)]
        {
            println!("[DEBUG] {}", format!($($arg)*));
        }
    };
}

macro_rules! log_info {
    ($($arg:tt)*) => {
        println!("[INFO] {}", format!($($arg)*));
    };
}

fn main() {
    log_debug!("这只在调试模式下显示: {}", 42);
    log_info!("这总是显示: {}", "hello");
}
```

### 4. 批量实现 trait

```rust
trait Describe {
    fn describe(&self) -> String;
}

macro_rules! impl_describe {
    ($($t:ty),*) => {
        $(
            impl Describe for $t {
                fn describe(&self) -> String {
                    format!("{} 类型的值: {}", stringify!($t), self)
                }
            }
        )*
    };
}

// 为多个类型实现 Describe
impl_describe!(i32, i64, f32, f64);

fn main() {
    let x: i32 = 42;
    let y: f64 = 3.14;
    
    println!("{}", x.describe());  // i32 类型的值: 42
    println!("{}", y.describe());  // f64 类型的值: 3.14
}
```

### 5. 枚举变体生成器

```rust
macro_rules! create_enum {
    ($name:ident { $($variant:ident),* }) => {
        enum $name {
            $($variant),*
        }
        
        impl $name {
            fn variants() -> Vec<&'static str> {
                vec![$(stringify!($variant)),*]
            }
        }
    };
}

create_enum!(Color { Red, Green, Blue, Yellow });

fn main() {
    let colors = Color::variants();
    println!("颜色: {:?}", colors);
    // 输出: 颜色: ["Red", "Green", "Blue", "Yellow"]
}
```

## 高级技巧

### 1. 递归宏

```rust
macro_rules! count {
    () => { 0 };
    ($x:expr) => { 1 };
    ($x:expr, $($rest:expr),+) => {
        1 + count!($($rest),+)
    };
}

fn main() {
    println!("数量: {}", count!(1, 2, 3, 4, 5));  // 5
}
```

### 2. TT Muncher 模式（逐个处理 token）

```rust
macro_rules! process {
    // 终止条件
    () => {
        println!("处理完成！");
    };
    // 处理一个元素，然后递归
    ($first:expr, $($rest:expr),*) => {
        println!("处理: {}", $first);
        process!($($rest),*);
    };
    // 单个元素
    ($first:expr) => {
        println!("最后一个: {}", $first);
    };
}

fn main() {
    process!(1, 2, 3, 4, 5);
}
```

### 3. 宏中的宏

```rust
macro_rules! create_macro {
    ($macro_name:ident) => {
        macro_rules! $macro_name {
            ($x:expr) => {
                println!("来自 {}: {}", stringify!($macro_name), $x);
            };
        }
    };
}

create_macro!(my_print);
create_macro!(my_debug);

fn main() {
    my_print!(42);      // 来自 my_print: 42
    my_debug!("hello"); // 来自 my_debug: hello
}
```

## 内置辅助宏

### `stringify!` - 转换为字符串

```rust
macro_rules! show_type {
    ($t:ty) => {
        println!("类型: {}", stringify!($t));
    };
}

fn main() {
    show_type!(i32);              // 类型: i32
    show_type!(Vec<String>);      // 类型: Vec<String>
}
```

### `concat!` - 连接字符串

```rust
fn main() {
    let message = concat!("Hello", " ", "World", "!");
    println!("{}", message);  // Hello World!
}
```

### `include_str!` - 包含文件内容

```rust
fn main() {
    let content = include_str!("../Cargo.toml");
    println!("Cargo.toml 内容:\n{}", content);
}
```

### `env!` - 获取环境变量

```rust
fn main() {
    let cargo_version = env!("CARGO_PKG_VERSION");
    println!("版本: {}", cargo_version);
}
```

## 标准库中的声明宏

### 1. `vec!`

```rust
let v1 = vec![1, 2, 3];
let v2 = vec![0; 5];  // [0, 0, 0, 0, 0]
```

### 2. `println!` / `format!`

```rust
println!("Hello, {}!", "World");
let s = format!("x = {}, y = {}", 10, 20);
```

### 3. `panic!`

```rust
panic!("出错了！");
panic!("错误: {}", error_message);
```

### 4. `assert!` / `assert_eq!`

```rust
assert!(x > 0);
assert_eq!(result, expected);
```

### 5. `matches!`

```rust
let value = Some(42);
if matches!(value, Some(x) if x > 10) {
    println!("值大于 10");
}
```

### 6. `dbg!`

```rust
let x = 5;
let y = dbg!(x * 2);  // 打印并返回值
```

### 7. `todo!` / `unimplemented!`

```rust
fn future_feature() {
    todo!("稍后实现");
}

fn not_implemented() {
    unimplemented!();
}
```

## 调试宏

### 使用 `cargo expand`

```bash
# 安装
cargo install cargo-expand

# 查看宏展开
cargo expand

# 查看特定函数
cargo expand module::function
```

### 在宏中打印调试信息

```rust
macro_rules! debug_macro {
    ($x:expr) => {
        {
            println!("宏输入: {}", stringify!($x));
            $x
        }
    };
}
```

## 最佳实践

### ✅ 好的做法

```rust
// 1. 使用括号包裹展开的代码，避免优先级问题
macro_rules! add {
    ($a:expr, $b:expr) => {
        ($a + $b)  // 注意括号
    };
}

// 2. 提供清晰的文档
/// 创建一个包含指定元素的向量
/// 
/// # 例子
/// ```
/// let v = my_vec![1, 2, 3];
/// ```
macro_rules! my_vec {
    // ...
}

// 3. 支持多种调用方式
macro_rules! flexible {
    ($x:expr) => { /* ... */ };
    ($x:expr, $y:expr) => { /* ... */ };
}
```

### ❌ 避免的做法

```rust
// 1. 避免过于复杂的宏
// 如果宏太复杂，考虑使用函数或过程宏

// 2. 避免不必要的宏
// 简单的情况用函数就好
fn greet(name: &str) {
    println!("Hello, {}!", name);
}

// 3. 避免宏名称冲突
// 不要用太通用的名称
```

## 声明宏 vs 过程宏

| 特性 | 声明宏 | 过程宏 |
|------|--------|--------|
| **定义** | `macro_rules!` | Rust 函数 |
| **复杂度** | 简单 | 复杂 |
| **功能** | 模式匹配 | 完全控制 |
| **编译速度** | 快 | 慢 |
| **依赖** | 无 | 需要 `syn`, `quote` |
| **使用场景** | 简单代码生成 | 复杂代码生成 |

## 何时使用声明宏

✅ **适合使用的场景**：
- 简单的代码重复
- 创建 DSL（领域特定语言）
- 编译时计算
- 创建类型安全的 API
- 减少样板代码

❌ **不适合的场景**：
- 需要分析类型信息
- 需要复杂的代码生成
- 需要更好的错误信息
- 公共 API（考虑过程宏）

## 总结

**声明宏**是 Rust 中基于模式匹配的宏系统：

1. **语法**：`macro_rules! 名称 { 模式 => 展开 }`
2. **核心**：模式匹配和代码替换
3. **优点**：简单、快速、无额外依赖
4. **用途**：减少重复代码、创建 DSL

与过程宏相比，声明宏更简单但功能有限。对于大多数简单场景，声明宏已经足够！🦀

## 参考资源

- [The Rust Book - Macros](https://doc.rust-lang.org/book/ch19-06-macros.html)
- [The Little Book of Rust Macros](https://veykril.github.io/tlborm/)
- [Rust by Example - Macros](https://doc.rust-lang.org/rust-by-example/macros.html)

