# Rust å£°æ˜å®ï¼ˆDeclarative Macrosï¼‰

## ä»€ä¹ˆæ˜¯å£°æ˜å®

**å£°æ˜å®**ï¼ˆDeclarative Macrosï¼‰ï¼Œä¹Ÿå« **macro_rules! å®**ï¼Œæ˜¯ Rust ä¸­åŸºäºæ¨¡å¼åŒ¹é…çš„å®ç³»ç»Ÿã€‚å®ƒé€šè¿‡åŒ¹é…ä»£ç æ¨¡å¼æ¥ç”Ÿæˆä»£ç ã€‚

## åŸºæœ¬è¯­æ³•

```rust
macro_rules! å®åç§° {
    (æ¨¡å¼1) => {
        ç”Ÿæˆçš„ä»£ç 1
    };
    (æ¨¡å¼2) => {
        ç”Ÿæˆçš„ä»£ç 2
    };
    // å¯ä»¥æœ‰å¤šä¸ªåˆ†æ”¯...
}
```

## ç®€å•ä¾‹å­

### ä¾‹å­ 1ï¼šæ— å‚æ•°å®

```rust
macro_rules! say_hello {
    () => {
        println!("ä½ å¥½ï¼Œä¸–ç•Œï¼");
    };
}

fn main() {
    say_hello!();  // è¾“å‡º: ä½ å¥½ï¼Œä¸–ç•Œï¼
}
```

### ä¾‹å­ 2ï¼šå¸¦å‚æ•°çš„å®

```rust
macro_rules! greet {
    ($name:expr) => {
        println!("ä½ å¥½, {}!", $name);
    };
}

fn main() {
    greet!("Alice");      // ä½ å¥½, Alice!
    greet!("Bob");        // ä½ å¥½, Bob!
    let name = "Charlie";
    greet!(name);         // ä½ å¥½, Charlie!
}
```

### ä¾‹å­ 3ï¼šå¤šä¸ªå‚æ•°

```rust
macro_rules! create_point {
    ($x:expr, $y:expr) => {
        Point { x: $x, y: $y }
    };
}

struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p1 = create_point!(10, 20);
    let p2 = create_point!(5 + 5, 10 * 2);
    println!("p1: ({}, {})", p1.x, p1.y);
}
```

## æ¨¡å¼åŒ¹é…æ ‡è¯†ç¬¦

| æ ‡è¯†ç¬¦ | è¯´æ˜ | ç¤ºä¾‹ |
|--------|------|------|
| `expr` | è¡¨è¾¾å¼ | `1 + 2`, `foo()`, `x` |
| `ident` | æ ‡è¯†ç¬¦ | å˜é‡åã€å‡½æ•°åã€ç±»å‹å |
| `ty` | ç±»å‹ | `i32`, `String`, `Vec<T>` |
| `path` | è·¯å¾„ | `std::io::Error` |
| `pat` | æ¨¡å¼ | `Some(x)`, `_`, `0..=10` |
| `stmt` | è¯­å¥ | `let x = 5;` |
| `block` | ä»£ç å— | `{ ... }` |
| `item` | é¡¹ | å‡½æ•°ã€ç»“æ„ä½“ã€trait ç­‰ |
| `meta` | å…ƒæ•°æ® | `#[derive(Debug)]` |
| `tt` | å•ä¸ªè¯­æ³•æ ‘ | ä»»ä½•å•ä¸ª token |
| `literal` | å­—é¢é‡ | `42`, `"hello"`, `true` |

### ä½¿ç”¨ä¸åŒæ ‡è¯†ç¬¦çš„ä¾‹å­

```rust
// expr - è¡¨è¾¾å¼
macro_rules! add {
    ($a:expr, $b:expr) => {
        $a + $b
    };
}

// ident - æ ‡è¯†ç¬¦ï¼ˆå¦‚å‡½æ•°åï¼‰
macro_rules! create_function {
    ($func_name:ident) => {
        fn $func_name() {
            println!("å‡½æ•° {} è¢«è°ƒç”¨äº†", stringify!($func_name));
        }
    };
}

// ty - ç±»å‹
macro_rules! create_struct {
    ($name:ident, $field_type:ty) => {
        struct $name {
            value: $field_type,
        }
    };
}

fn main() {
    // ä½¿ç”¨ add å®
    let sum = add!(5, 10);
    println!("sum: {}", sum);
    
    // ä½¿ç”¨ create_function å®
    create_function!(hello);
    hello();
    
    // ä½¿ç”¨ create_struct å®
    create_struct!(Container, i32);
    let c = Container { value: 42 };
}
```

## é‡å¤æ¨¡å¼

ä½¿ç”¨ `$(...)*` æˆ– `$(...)+ ` å¤„ç†å¯å˜æ•°é‡çš„å‚æ•°ã€‚

### é›¶æ¬¡æˆ–å¤šæ¬¡ `$(...)*`

```rust
// æ ‡å‡†åº“çš„ vec! å®ç®€åŒ–ç‰ˆ
macro_rules! my_vec {
    ( $( $x:expr ),* ) => {
        {
            let mut temp_vec = Vec::new();
            $(
                temp_vec.push($x);
            )*
            temp_vec
        }
    };
}

fn main() {
    let v1 = my_vec![1, 2, 3, 4, 5];
    let v2 = my_vec![];  // ç©ºå‘é‡ä¹Ÿå¯ä»¥
    let v3 = my_vec![10];
    
    println!("{:?}", v1);  // [1, 2, 3, 4, 5]
}
```

### ä¸€æ¬¡æˆ–å¤šæ¬¡ `$(...)+`

```rust
macro_rules! print_all {
    ( $( $x:expr ),+ ) => {
        $(
            println!("{}", $x);
        )+
    };
}

fn main() {
    print_all!(1, 2, 3);
    // è¾“å‡º:
    // 1
    // 2
    // 3
    
    // print_all!();  // é”™è¯¯ï¼è‡³å°‘éœ€è¦ä¸€ä¸ªå‚æ•°
}
```

## å¤šåˆ†æ”¯æ¨¡å¼

```rust
macro_rules! calculate {
    // åŠ æ³•
    (add $a:expr, $b:expr) => {
        $a + $b
    };
    
    // å‡æ³•
    (sub $a:expr, $b:expr) => {
        $a - $b
    };
    
    // ä¹˜æ³•
    (mul $a:expr, $b:expr) => {
        $a * $b
    };
    
    // é™¤æ³•
    (div $a:expr, $b:expr) => {
        $a / $b
    };
}

fn main() {
    println!("10 + 5 = {}", calculate!(add 10, 5));   // 15
    println!("10 - 5 = {}", calculate!(sub 10, 5));   // 5
    println!("10 * 5 = {}", calculate!(mul 10, 5));   // 50
    println!("10 / 5 = {}", calculate!(div 10, 5));   // 2
}
```

## å®ç”¨å®ä¾‹å­

### 1. HashMap å­—é¢é‡

```rust
macro_rules! hashmap {
    ( $( $key:expr => $val:expr ),* ) => {
        {
            let mut map = ::std::collections::HashMap::new();
            $(
                map.insert($key, $val);
            )*
            map
        }
    };
}

fn main() {
    let map = hashmap! {
        "name" => "Alice",
        "age" => "30",
        "city" => "Beijing"
    };
    
    println!("{:?}", map);
}
```

### 2. æµ‹è¯•ç”¨ä¾‹ç”Ÿæˆå™¨

```rust
macro_rules! test_case {
    ($name:ident: $input:expr => $expected:expr) => {
        #[test]
        fn $name() {
            assert_eq!(double($input), $expected);
        }
    };
}

fn double(x: i32) -> i32 {
    x * 2
}

// ç”Ÿæˆå¤šä¸ªæµ‹è¯•
test_case!(test_zero: 0 => 0);
test_case!(test_positive: 5 => 10);
test_case!(test_negative: -3 => -6);
```

### 3. æ¡ä»¶æ—¥å¿—å®

```rust
macro_rules! log_debug {
    ($($arg:tt)*) => {
        #[cfg(debug_assertions)]
        {
            println!("[DEBUG] {}", format!($($arg)*));
        }
    };
}

macro_rules! log_info {
    ($($arg:tt)*) => {
        println!("[INFO] {}", format!($($arg)*));
    };
}

fn main() {
    log_debug!("è¿™åªåœ¨è°ƒè¯•æ¨¡å¼ä¸‹æ˜¾ç¤º: {}", 42);
    log_info!("è¿™æ€»æ˜¯æ˜¾ç¤º: {}", "hello");
}
```

### 4. æ‰¹é‡å®ç° trait

```rust
trait Describe {
    fn describe(&self) -> String;
}

macro_rules! impl_describe {
    ($($t:ty),*) => {
        $(
            impl Describe for $t {
                fn describe(&self) -> String {
                    format!("{} ç±»å‹çš„å€¼: {}", stringify!($t), self)
                }
            }
        )*
    };
}

// ä¸ºå¤šä¸ªç±»å‹å®ç° Describe
impl_describe!(i32, i64, f32, f64);

fn main() {
    let x: i32 = 42;
    let y: f64 = 3.14;
    
    println!("{}", x.describe());  // i32 ç±»å‹çš„å€¼: 42
    println!("{}", y.describe());  // f64 ç±»å‹çš„å€¼: 3.14
}
```

### 5. æšä¸¾å˜ä½“ç”Ÿæˆå™¨

```rust
macro_rules! create_enum {
    ($name:ident { $($variant:ident),* }) => {
        enum $name {
            $($variant),*
        }
        
        impl $name {
            fn variants() -> Vec<&'static str> {
                vec![$(stringify!($variant)),*]
            }
        }
    };
}

create_enum!(Color { Red, Green, Blue, Yellow });

fn main() {
    let colors = Color::variants();
    println!("é¢œè‰²: {:?}", colors);
    // è¾“å‡º: é¢œè‰²: ["Red", "Green", "Blue", "Yellow"]
}
```

## é«˜çº§æŠ€å·§

### 1. é€’å½’å®

```rust
macro_rules! count {
    () => { 0 };
    ($x:expr) => { 1 };
    ($x:expr, $($rest:expr),+) => {
        1 + count!($($rest),+)
    };
}

fn main() {
    println!("æ•°é‡: {}", count!(1, 2, 3, 4, 5));  // 5
}
```

### 2. TT Muncher æ¨¡å¼ï¼ˆé€ä¸ªå¤„ç† tokenï¼‰

```rust
macro_rules! process {
    // ç»ˆæ­¢æ¡ä»¶
    () => {
        println!("å¤„ç†å®Œæˆï¼");
    };
    // å¤„ç†ä¸€ä¸ªå…ƒç´ ï¼Œç„¶åé€’å½’
    ($first:expr, $($rest:expr),*) => {
        println!("å¤„ç†: {}", $first);
        process!($($rest),*);
    };
    // å•ä¸ªå…ƒç´ 
    ($first:expr) => {
        println!("æœ€åä¸€ä¸ª: {}", $first);
    };
}

fn main() {
    process!(1, 2, 3, 4, 5);
}
```

### 3. å®ä¸­çš„å®

```rust
macro_rules! create_macro {
    ($macro_name:ident) => {
        macro_rules! $macro_name {
            ($x:expr) => {
                println!("æ¥è‡ª {}: {}", stringify!($macro_name), $x);
            };
        }
    };
}

create_macro!(my_print);
create_macro!(my_debug);

fn main() {
    my_print!(42);      // æ¥è‡ª my_print: 42
    my_debug!("hello"); // æ¥è‡ª my_debug: hello
}
```

## å†…ç½®è¾…åŠ©å®

### `stringify!` - è½¬æ¢ä¸ºå­—ç¬¦ä¸²

```rust
macro_rules! show_type {
    ($t:ty) => {
        println!("ç±»å‹: {}", stringify!($t));
    };
}

fn main() {
    show_type!(i32);              // ç±»å‹: i32
    show_type!(Vec<String>);      // ç±»å‹: Vec<String>
}
```

### `concat!` - è¿æ¥å­—ç¬¦ä¸²

```rust
fn main() {
    let message = concat!("Hello", " ", "World", "!");
    println!("{}", message);  // Hello World!
}
```

### `include_str!` - åŒ…å«æ–‡ä»¶å†…å®¹

```rust
fn main() {
    let content = include_str!("../Cargo.toml");
    println!("Cargo.toml å†…å®¹:\n{}", content);
}
```

### `env!` - è·å–ç¯å¢ƒå˜é‡

```rust
fn main() {
    let cargo_version = env!("CARGO_PKG_VERSION");
    println!("ç‰ˆæœ¬: {}", cargo_version);
}
```

## æ ‡å‡†åº“ä¸­çš„å£°æ˜å®

### 1. `vec!`

```rust
let v1 = vec![1, 2, 3];
let v2 = vec![0; 5];  // [0, 0, 0, 0, 0]
```

### 2. `println!` / `format!`

```rust
println!("Hello, {}!", "World");
let s = format!("x = {}, y = {}", 10, 20);
```

### 3. `panic!`

```rust
panic!("å‡ºé”™äº†ï¼");
panic!("é”™è¯¯: {}", error_message);
```

### 4. `assert!` / `assert_eq!`

```rust
assert!(x > 0);
assert_eq!(result, expected);
```

### 5. `matches!`

```rust
let value = Some(42);
if matches!(value, Some(x) if x > 10) {
    println!("å€¼å¤§äº 10");
}
```

### 6. `dbg!`

```rust
let x = 5;
let y = dbg!(x * 2);  // æ‰“å°å¹¶è¿”å›å€¼
```

### 7. `todo!` / `unimplemented!`

```rust
fn future_feature() {
    todo!("ç¨åå®ç°");
}

fn not_implemented() {
    unimplemented!();
}
```

## è°ƒè¯•å®

### ä½¿ç”¨ `cargo expand`

```bash
# å®‰è£…
cargo install cargo-expand

# æŸ¥çœ‹å®å±•å¼€
cargo expand

# æŸ¥çœ‹ç‰¹å®šå‡½æ•°
cargo expand module::function
```

### åœ¨å®ä¸­æ‰“å°è°ƒè¯•ä¿¡æ¯

```rust
macro_rules! debug_macro {
    ($x:expr) => {
        {
            println!("å®è¾“å…¥: {}", stringify!($x));
            $x
        }
    };
}
```

## æœ€ä½³å®è·µ

### âœ… å¥½çš„åšæ³•

```rust
// 1. ä½¿ç”¨æ‹¬å·åŒ…è£¹å±•å¼€çš„ä»£ç ï¼Œé¿å…ä¼˜å…ˆçº§é—®é¢˜
macro_rules! add {
    ($a:expr, $b:expr) => {
        ($a + $b)  // æ³¨æ„æ‹¬å·
    };
}

// 2. æä¾›æ¸…æ™°çš„æ–‡æ¡£
/// åˆ›å»ºä¸€ä¸ªåŒ…å«æŒ‡å®šå…ƒç´ çš„å‘é‡
/// 
/// # ä¾‹å­
/// ```
/// let v = my_vec![1, 2, 3];
/// ```
macro_rules! my_vec {
    // ...
}

// 3. æ”¯æŒå¤šç§è°ƒç”¨æ–¹å¼
macro_rules! flexible {
    ($x:expr) => { /* ... */ };
    ($x:expr, $y:expr) => { /* ... */ };
}
```

### âŒ é¿å…çš„åšæ³•

```rust
// 1. é¿å…è¿‡äºå¤æ‚çš„å®
// å¦‚æœå®å¤ªå¤æ‚ï¼Œè€ƒè™‘ä½¿ç”¨å‡½æ•°æˆ–è¿‡ç¨‹å®

// 2. é¿å…ä¸å¿…è¦çš„å®
// ç®€å•çš„æƒ…å†µç”¨å‡½æ•°å°±å¥½
fn greet(name: &str) {
    println!("Hello, {}!", name);
}

// 3. é¿å…å®åç§°å†²çª
// ä¸è¦ç”¨å¤ªé€šç”¨çš„åç§°
```

## å£°æ˜å® vs è¿‡ç¨‹å®

| ç‰¹æ€§ | å£°æ˜å® | è¿‡ç¨‹å® |
|------|--------|--------|
| **å®šä¹‰** | `macro_rules!` | Rust å‡½æ•° |
| **å¤æ‚åº¦** | ç®€å• | å¤æ‚ |
| **åŠŸèƒ½** | æ¨¡å¼åŒ¹é… | å®Œå…¨æ§åˆ¶ |
| **ç¼–è¯‘é€Ÿåº¦** | å¿« | æ…¢ |
| **ä¾èµ–** | æ—  | éœ€è¦ `syn`, `quote` |
| **ä½¿ç”¨åœºæ™¯** | ç®€å•ä»£ç ç”Ÿæˆ | å¤æ‚ä»£ç ç”Ÿæˆ |

## ä½•æ—¶ä½¿ç”¨å£°æ˜å®

âœ… **é€‚åˆä½¿ç”¨çš„åœºæ™¯**ï¼š
- ç®€å•çš„ä»£ç é‡å¤
- åˆ›å»º DSLï¼ˆé¢†åŸŸç‰¹å®šè¯­è¨€ï¼‰
- ç¼–è¯‘æ—¶è®¡ç®—
- åˆ›å»ºç±»å‹å®‰å…¨çš„ API
- å‡å°‘æ ·æ¿ä»£ç 

âŒ **ä¸é€‚åˆçš„åœºæ™¯**ï¼š
- éœ€è¦åˆ†æç±»å‹ä¿¡æ¯
- éœ€è¦å¤æ‚çš„ä»£ç ç”Ÿæˆ
- éœ€è¦æ›´å¥½çš„é”™è¯¯ä¿¡æ¯
- å…¬å…± APIï¼ˆè€ƒè™‘è¿‡ç¨‹å®ï¼‰

## æ€»ç»“

**å£°æ˜å®**æ˜¯ Rust ä¸­åŸºäºæ¨¡å¼åŒ¹é…çš„å®ç³»ç»Ÿï¼š

1. **è¯­æ³•**ï¼š`macro_rules! åç§° { æ¨¡å¼ => å±•å¼€ }`
2. **æ ¸å¿ƒ**ï¼šæ¨¡å¼åŒ¹é…å’Œä»£ç æ›¿æ¢
3. **ä¼˜ç‚¹**ï¼šç®€å•ã€å¿«é€Ÿã€æ— é¢å¤–ä¾èµ–
4. **ç”¨é€”**ï¼šå‡å°‘é‡å¤ä»£ç ã€åˆ›å»º DSL

ä¸è¿‡ç¨‹å®ç›¸æ¯”ï¼Œå£°æ˜å®æ›´ç®€å•ä½†åŠŸèƒ½æœ‰é™ã€‚å¯¹äºå¤§å¤šæ•°ç®€å•åœºæ™¯ï¼Œå£°æ˜å®å·²ç»è¶³å¤Ÿï¼ğŸ¦€

## å‚è€ƒèµ„æº

- [The Rust Book - Macros](https://doc.rust-lang.org/book/ch19-06-macros.html)
- [The Little Book of Rust Macros](https://veykril.github.io/tlborm/)
- [Rust by Example - Macros](https://doc.rust-lang.org/rust-by-example/macros.html)

