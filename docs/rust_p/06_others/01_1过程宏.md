# Rust 过程宏（Procedural Macros）

## 什么是过程宏

**过程宏**（Procedural Macros）是 Rust 中一种高级的元编程工具，可以在**编译时**接收 Rust 代码作为输入，并生成新的 Rust 代码作为输出。

简单来说：**过程宏是可以操作代码的代码！**

```
输入代码 → 过程宏处理 → 输出代码 → 编译器编译
```

## 宏的分类

Rust 中有两大类宏：

### 1. 声明宏（Declarative Macros）

```rust
// 使用 macro_rules! 定义
macro_rules! vec {
    ( $( $x:expr ),* ) => {
        {
            let mut temp_vec = Vec::new();
            $(
                temp_vec.push($x);
            )*
            temp_vec
        }
    };
}

// 使用
let v = vec![1, 2, 3];
```

**特点**：
- 基于模式匹配
- 相对简单
- 功能有限

### 2. 过程宏（Procedural Macros）⭐

```rust
// 可以做更复杂的代码生成
#[derive(Debug)]  // 这是一个过程宏！
struct Point {
    x: i32,
    y: i32,
}
```

**特点**：
- 功能强大
- 可以解析和生成任意 Rust 代码
- 本质是 Rust 函数

---

## 过程宏的三种类型

### 1. 派生宏（Derive Macros）

**最常见的过程宏类型**，使用 `#[derive(...)]` 语法。

```rust
// 自动为结构体实现 Debug trait
#[derive(Debug, Clone, PartialEq)]
struct User {
    name: String,
    age: u32,
}

// 相当于自动生成了：
impl std::fmt::Debug for User {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        // 自动生成的实现...
    }
}

impl Clone for User {
    fn clone(&self) -> Self {
        // 自动生成的实现...
    }
}

impl PartialEq for User {
    fn eq(&self, other: &Self) -> bool {
        // 自动生成的实现...
    }
}
```

**标准库内置的派生宏**：
- `Debug`, `Clone`, `Copy`
- `PartialEq`, `Eq`, `PartialOrd`, `Ord`
- `Hash`, `Default`

**第三方库的派生宏**：
```rust
use serde::{Serialize, Deserialize};

#[derive(Serialize, Deserialize)]
struct Config {
    host: String,
    port: u16,
}
// 自动生成序列化/反序列化代码
```

---

### 2. 属性宏（Attribute Macros）

类似于装饰器，可以应用在**任何项**（函数、结构体、模块等）上。

```rust
// 使用属性宏
#[route(GET, "/")]
fn index() -> String {
    "Hello, World!".to_string()
}

// 可以应用在结构体上
#[derive(Debug)]
#[table_name = "users"]  // 这也是属性宏
struct User {
    id: i32,
    name: String,
}

// 可以应用在模块上
#[cfg(test)]
mod tests {
    // ...
}
```

**常见的属性宏**：
- `#[test]` - 标记测试函数
- `#[tokio::main]` - 异步运行时入口
- `#[wasm_bindgen]` - WebAssembly 绑定
- `#[uniffi::export]` - UniFFI 导出

**例子：Tokio 的 async main**
```rust
// 使用属性宏
#[tokio::main]
async fn main() {
    println!("Hello, async!");
}

// 宏展开后大致相当于：
fn main() {
    tokio::runtime::Builder::new_multi_thread()
        .enable_all()
        .build()
        .unwrap()
        .block_on(async {
            println!("Hello, async!");
        })
}
```

---

### 3. 函数式宏（Function-like Macros）

看起来像函数调用，但实际上在编译时处理代码。

```rust
// 看起来像函数调用
let sql = sql!("SELECT * FROM users WHERE id = ?");

// 但它是在编译时执行的宏
let html = html! {
    <div class="container">
        <h1>{"Hello"}</h1>
    </div>
};
```

**与普通函数的区别**：
```rust
// 普通函数 - 运行时执行
fn create_vec() -> Vec<i32> {
    vec![1, 2, 3]
}

// 函数式宏 - 编译时展开
macro_rules! create_vec {
    () => {
        vec![1, 2, 3]
    };
}
```

---

## 过程宏是如何工作的

### 编译流程

```
1. 编写代码
   ↓
2. 编译器解析代码为 TokenStream（词法单元流）
   ↓
3. 过程宏接收 TokenStream
   ↓
4. 过程宏生成新的 TokenStream
   ↓
5. 编译器继续编译生成的代码
```

### 过程宏的签名

```rust
// 派生宏的签名
#[proc_macro_derive(MyDerive)]
pub fn my_derive(input: TokenStream) -> TokenStream {
    // input: 输入的代码（如结构体定义）
    // 返回: 生成的代码（如 trait 实现）
}

// 属性宏的签名
#[proc_macro_attribute]
pub fn my_attribute(attr: TokenStream, item: TokenStream) -> TokenStream {
    // attr: 属性的参数
    // item: 被修饰的项
    // 返回: 修改后的代码
}

// 函数式宏的签名
#[proc_macro]
pub fn my_macro(input: TokenStream) -> TokenStream {
    // input: 宏调用时传入的代码
    // 返回: 生成的代码
}
```

---

## 创建自定义过程宏

### 项目结构

```toml
# Cargo.toml
[package]
name = "my_macro"
version = "0.1.0"
edition = "2021"

[lib]
proc-macro = true  # 必须！标记这是过程宏库

[dependencies]
syn = "2.0"        # 解析 Rust 代码
quote = "1.0"      # 生成 Rust 代码
proc-macro2 = "1.0"
```

### 例子 1：简单的派生宏

```rust
// my_macro/src/lib.rs
use proc_macro::TokenStream;
use quote::quote;
use syn::{parse_macro_input, DeriveInput};

// 定义一个派生宏 HelloMacro
#[proc_macro_derive(HelloMacro)]
pub fn hello_macro_derive(input: TokenStream) -> TokenStream {
    // 解析输入
    let input = parse_macro_input!(input as DeriveInput);
    let name = &input.ident;  // 获取结构体名称
    
    // 生成代码
    let expanded = quote! {
        impl HelloMacro for #name {
            fn hello() {
                println!("Hello from {}!", stringify!(#name));
            }
        }
    };
    
    // 返回生成的代码
    TokenStream::from(expanded)
}
```

**使用自定义宏**：
```rust
// 在另一个项目中
use my_macro::HelloMacro;

trait HelloMacro {
    fn hello();
}

#[derive(HelloMacro)]
struct Person;

#[derive(HelloMacro)]
struct Robot;

fn main() {
    Person::hello();  // 输出: Hello from Person!
    Robot::hello();   // 输出: Hello from Robot!
}
```

### 例子 2：属性宏 - 性能计时

```rust
use proc_macro::TokenStream;
use quote::quote;
use syn::{parse_macro_input, ItemFn};

#[proc_macro_attribute]
pub fn timing(_attr: TokenStream, item: TokenStream) -> TokenStream {
    let input_fn = parse_macro_input!(item as ItemFn);
    let fn_name = &input_fn.sig.ident;
    let fn_block = &input_fn.block;
    let fn_sig = &input_fn.sig;
    let fn_vis = &input_fn.vis;
    
    let expanded = quote! {
        #fn_vis #fn_sig {
            let start = std::time::Instant::now();
            let result = (|| #fn_block)();
            let duration = start.elapsed();
            println!("{} 执行时间: {:?}", stringify!(#fn_name), duration);
            result
        }
    };
    
    TokenStream::from(expanded)
}
```

**使用**：
```rust
#[timing]
fn slow_function() {
    std::thread::sleep(std::time::Duration::from_secs(1));
    println!("完成！");
}

fn main() {
    slow_function();
    // 输出:
    // 完成！
    // slow_function 执行时间: 1.00s
}
```

### 例子 3：函数式宏 - SQL 验证

```rust
use proc_macro::TokenStream;
use quote::quote;

#[proc_macro]
pub fn sql(input: TokenStream) -> TokenStream {
    let sql_query = input.to_string();
    
    // 在编译时验证 SQL 语法
    if !sql_query.to_uppercase().contains("SELECT") {
        panic!("无效的 SQL 查询！");
    }
    
    // 生成代码
    let expanded = quote! {
        String::from(#sql_query)
    };
    
    TokenStream::from(expanded)
}
```

**使用**：
```rust
fn main() {
    let query = sql!("SELECT * FROM users");  // ✅ 编译通过
    // let bad = sql!("INVALID SQL");         // ❌ 编译错误
}
```

---

## 常见的过程宏库

### 1. Serde - 序列化/反序列化

```rust
use serde::{Serialize, Deserialize};

#[derive(Serialize, Deserialize)]
struct Config {
    name: String,
    version: String,
}
```

### 2. Tokio - 异步运行时

```rust
#[tokio::main]
async fn main() {
    // 异步代码
}

#[tokio::test]
async fn test_async() {
    // 异步测试
}
```

### 3. Diesel - ORM

```rust
#[derive(Queryable)]
struct User {
    id: i32,
    name: String,
}

table! {
    users (id) {
        id -> Integer,
        name -> Text,
    }
}
```

### 4. Actix-web - Web 框架

```rust
#[get("/")]
async fn index() -> impl Responder {
    HttpResponse::Ok().body("Hello!")
}

#[post("/users")]
async fn create_user(user: web::Json<User>) -> impl Responder {
    // ...
}
```

### 5. Thiserror - 错误处理

```rust
use thiserror::Error;

#[derive(Error, Debug)]
pub enum MyError {
    #[error("文件未找到: {path}")]
    NotFound { path: String },
    
    #[error("IO 错误")]
    Io(#[from] std::io::Error),
}
```

---

## 过程宏 vs 声明宏

| 特性 | 声明宏 | 过程宏 |
|------|--------|--------|
| **定义方式** | `macro_rules!` | Rust 函数 + 特殊属性 |
| **功能** | 基于模式匹配 | 可以任意处理代码 |
| **复杂度** | 简单 | 复杂但强大 |
| **编译时间** | 快 | 较慢 |
| **错误信息** | 较差 | 较好 |
| **使用场景** | 简单重复代码 | 复杂代码生成 |

**声明宏例子**：
```rust
macro_rules! say_hello {
    () => {
        println!("Hello!");
    };
}
```

**过程宏例子**：
```rust
#[derive(Debug)]  // 可以检查结构体定义，生成复杂代码
struct Point { x: i32, y: i32 }
```

---

## 过程宏的优缺点

### ✅ 优点

1. **减少样板代码**
```rust
// 不用写
impl Debug for User { /* 很多代码 */ }
impl Clone for User { /* 很多代码 */ }

// 只需写
#[derive(Debug, Clone)]
struct User { /* ... */ }
```

2. **编译时代码生成**
```rust
// 在编译时就生成优化的代码
#[derive(Serialize)]
struct Data { /* ... */ }
```

3. **类型安全**
```rust
// 宏可以检查类型，提供编译时保证
sql!("SELECT * FROM users");  // 编译时验证
```

4. **零运行时开销**
- 所有代码在编译时生成
- 没有反射的性能损耗

### ❌ 缺点

1. **编译时间增加**
- 大量使用过程宏会显著增加编译时间

2. **调试困难**
- 生成的代码不可见
- 错误信息可能不清晰

3. **学习曲线陡峭**
- 需要理解 `syn`, `quote` 等库
- 需要理解 TokenStream

4. **IDE 支持有限**
- 自动补全可能不完整
- 跳转定义可能不准确

---

## 调试过程宏

### 1. 使用 `cargo expand`

```bash
# 安装
cargo install cargo-expand

# 查看宏展开后的代码
cargo expand

# 查看特定模块
cargo expand module_name
```

**例子**：
```rust
#[derive(Debug)]
struct Point { x: i32, y: i32 }

// cargo expand 后看到：
impl std::fmt::Debug for Point {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        f.debug_struct("Point")
            .field("x", &self.x)
            .field("y", &self.y)
            .finish()
    }
}
```

### 2. 使用 `eprintln!` 调试

```rust
#[proc_macro_derive(MyMacro)]
pub fn my_macro(input: TokenStream) -> TokenStream {
    // 打印输入
    eprintln!("输入: {}", input);
    
    let parsed = parse_macro_input!(input as DeriveInput);
    eprintln!("解析后: {:?}", parsed);
    
    // ...
}
```

---

## 最佳实践

### 1. ✅ 为复杂场景使用过程宏

```rust
// ✅ 好的使用场景
#[derive(Serialize, Deserialize)]  // 生成复杂的序列化代码
struct Config { /* ... */ }
```

### 2. ❌ 不要过度使用

```rust
// ❌ 简单的情况不需要宏
// 与其写一个宏，不如直接写函数
fn greet(name: &str) {
    println!("Hello, {}!", name);
}
```

### 3. ✅ 提供清晰的错误信息

```rust
#[proc_macro_derive(MyMacro)]
pub fn my_macro(input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as DeriveInput);
    
    // ✅ 好的错误信息
    if input.generics.params.is_empty() {
        return syn::Error::new(
            input.ident.span(),
            "MyMacro 只能用于泛型类型"
        ).to_compile_error().into();
    }
    
    // ...
}
```

### 4. ✅ 编写测试

```rust
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_macro() {
        let input = quote! {
            struct Test { field: i32 }
        };
        let output = my_macro(input.into());
        // 验证输出
    }
}
```

---

## 总结

**过程宏**是 Rust 中强大的元编程工具：

1. **三种类型**：
   - 派生宏 `#[derive(...)]`
   - 属性宏 `#[attr]`
   - 函数式宏 `macro!(...)`

2. **核心概念**：
   - 在编译时处理代码
   - 输入和输出都是 `TokenStream`
   - 可以生成任意 Rust 代码

3. **常见用途**：
   - 自动实现 trait（Debug, Serialize 等）
   - 减少样板代码
   - 编译时验证
   - DSL（领域特定语言）

4. **权衡**：
   - ✅ 强大、类型安全、零运行时开销
   - ❌ 增加编译时间、调试困难

过程宏让 Rust 的表达能力大大增强，但要适度使用！🦀

---

## 参考资源

- [The Rust Book - Macros](https://doc.rust-lang.org/book/ch19-06-macros.html)
- [Procedural Macros Workshop](https://github.com/dtolnay/proc-macro-workshop)
- [syn 文档](https://docs.rs/syn/)
- [quote 文档](https://docs.rs/quote/)

