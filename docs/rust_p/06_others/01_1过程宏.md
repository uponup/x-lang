# Rust è¿‡ç¨‹å®ï¼ˆProcedural Macrosï¼‰

## ä»€ä¹ˆæ˜¯è¿‡ç¨‹å®

**è¿‡ç¨‹å®**ï¼ˆProcedural Macrosï¼‰æ˜¯ Rust ä¸­ä¸€ç§é«˜çº§çš„å…ƒç¼–ç¨‹å·¥å…·ï¼Œå¯ä»¥åœ¨**ç¼–è¯‘æ—¶**æ¥æ”¶ Rust ä»£ç ä½œä¸ºè¾“å…¥ï¼Œå¹¶ç”Ÿæˆæ–°çš„ Rust ä»£ç ä½œä¸ºè¾“å‡ºã€‚

ç®€å•æ¥è¯´ï¼š**è¿‡ç¨‹å®æ˜¯å¯ä»¥æ“ä½œä»£ç çš„ä»£ç ï¼**

```
è¾“å…¥ä»£ç  â†’ è¿‡ç¨‹å®å¤„ç† â†’ è¾“å‡ºä»£ç  â†’ ç¼–è¯‘å™¨ç¼–è¯‘
```

## å®çš„åˆ†ç±»

Rust ä¸­æœ‰ä¸¤å¤§ç±»å®ï¼š

### 1. å£°æ˜å®ï¼ˆDeclarative Macrosï¼‰

```rust
// ä½¿ç”¨ macro_rules! å®šä¹‰
macro_rules! vec {
    ( $( $x:expr ),* ) => {
        {
            let mut temp_vec = Vec::new();
            $(
                temp_vec.push($x);
            )*
            temp_vec
        }
    };
}

// ä½¿ç”¨
let v = vec![1, 2, 3];
```

**ç‰¹ç‚¹**ï¼š
- åŸºäºæ¨¡å¼åŒ¹é…
- ç›¸å¯¹ç®€å•
- åŠŸèƒ½æœ‰é™

### 2. è¿‡ç¨‹å®ï¼ˆProcedural Macrosï¼‰â­

```rust
// å¯ä»¥åšæ›´å¤æ‚çš„ä»£ç ç”Ÿæˆ
#[derive(Debug)]  // è¿™æ˜¯ä¸€ä¸ªè¿‡ç¨‹å®ï¼
struct Point {
    x: i32,
    y: i32,
}
```

**ç‰¹ç‚¹**ï¼š
- åŠŸèƒ½å¼ºå¤§
- å¯ä»¥è§£æå’Œç”Ÿæˆä»»æ„ Rust ä»£ç 
- æœ¬è´¨æ˜¯ Rust å‡½æ•°

---

## è¿‡ç¨‹å®çš„ä¸‰ç§ç±»å‹

### 1. æ´¾ç”Ÿå®ï¼ˆDerive Macrosï¼‰

**æœ€å¸¸è§çš„è¿‡ç¨‹å®ç±»å‹**ï¼Œä½¿ç”¨ `#[derive(...)]` è¯­æ³•ã€‚

```rust
// è‡ªåŠ¨ä¸ºç»“æ„ä½“å®ç° Debug trait
#[derive(Debug, Clone, PartialEq)]
struct User {
    name: String,
    age: u32,
}

// ç›¸å½“äºè‡ªåŠ¨ç”Ÿæˆäº†ï¼š
impl std::fmt::Debug for User {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        // è‡ªåŠ¨ç”Ÿæˆçš„å®ç°...
    }
}

impl Clone for User {
    fn clone(&self) -> Self {
        // è‡ªåŠ¨ç”Ÿæˆçš„å®ç°...
    }
}

impl PartialEq for User {
    fn eq(&self, other: &Self) -> bool {
        // è‡ªåŠ¨ç”Ÿæˆçš„å®ç°...
    }
}
```

**æ ‡å‡†åº“å†…ç½®çš„æ´¾ç”Ÿå®**ï¼š
- `Debug`, `Clone`, `Copy`
- `PartialEq`, `Eq`, `PartialOrd`, `Ord`
- `Hash`, `Default`

**ç¬¬ä¸‰æ–¹åº“çš„æ´¾ç”Ÿå®**ï¼š
```rust
use serde::{Serialize, Deserialize};

#[derive(Serialize, Deserialize)]
struct Config {
    host: String,
    port: u16,
}
// è‡ªåŠ¨ç”Ÿæˆåºåˆ—åŒ–/ååºåˆ—åŒ–ä»£ç 
```

---

### 2. å±æ€§å®ï¼ˆAttribute Macrosï¼‰

ç±»ä¼¼äºè£…é¥°å™¨ï¼Œå¯ä»¥åº”ç”¨åœ¨**ä»»ä½•é¡¹**ï¼ˆå‡½æ•°ã€ç»“æ„ä½“ã€æ¨¡å—ç­‰ï¼‰ä¸Šã€‚

```rust
// ä½¿ç”¨å±æ€§å®
#[route(GET, "/")]
fn index() -> String {
    "Hello, World!".to_string()
}

// å¯ä»¥åº”ç”¨åœ¨ç»“æ„ä½“ä¸Š
#[derive(Debug)]
#[table_name = "users"]  // è¿™ä¹Ÿæ˜¯å±æ€§å®
struct User {
    id: i32,
    name: String,
}

// å¯ä»¥åº”ç”¨åœ¨æ¨¡å—ä¸Š
#[cfg(test)]
mod tests {
    // ...
}
```

**å¸¸è§çš„å±æ€§å®**ï¼š
- `#[test]` - æ ‡è®°æµ‹è¯•å‡½æ•°
- `#[tokio::main]` - å¼‚æ­¥è¿è¡Œæ—¶å…¥å£
- `#[wasm_bindgen]` - WebAssembly ç»‘å®š
- `#[uniffi::export]` - UniFFI å¯¼å‡º

**ä¾‹å­ï¼šTokio çš„ async main**
```rust
// ä½¿ç”¨å±æ€§å®
#[tokio::main]
async fn main() {
    println!("Hello, async!");
}

// å®å±•å¼€åå¤§è‡´ç›¸å½“äºï¼š
fn main() {
    tokio::runtime::Builder::new_multi_thread()
        .enable_all()
        .build()
        .unwrap()
        .block_on(async {
            println!("Hello, async!");
        })
}
```

---

### 3. å‡½æ•°å¼å®ï¼ˆFunction-like Macrosï¼‰

çœ‹èµ·æ¥åƒå‡½æ•°è°ƒç”¨ï¼Œä½†å®é™…ä¸Šåœ¨ç¼–è¯‘æ—¶å¤„ç†ä»£ç ã€‚

```rust
// çœ‹èµ·æ¥åƒå‡½æ•°è°ƒç”¨
let sql = sql!("SELECT * FROM users WHERE id = ?");

// ä½†å®ƒæ˜¯åœ¨ç¼–è¯‘æ—¶æ‰§è¡Œçš„å®
let html = html! {
    <div class="container">
        <h1>{"Hello"}</h1>
    </div>
};
```

**ä¸æ™®é€šå‡½æ•°çš„åŒºåˆ«**ï¼š
```rust
// æ™®é€šå‡½æ•° - è¿è¡Œæ—¶æ‰§è¡Œ
fn create_vec() -> Vec<i32> {
    vec![1, 2, 3]
}

// å‡½æ•°å¼å® - ç¼–è¯‘æ—¶å±•å¼€
macro_rules! create_vec {
    () => {
        vec![1, 2, 3]
    };
}
```

---

## è¿‡ç¨‹å®æ˜¯å¦‚ä½•å·¥ä½œçš„

### ç¼–è¯‘æµç¨‹

```
1. ç¼–å†™ä»£ç 
   â†“
2. ç¼–è¯‘å™¨è§£æä»£ç ä¸º TokenStreamï¼ˆè¯æ³•å•å…ƒæµï¼‰
   â†“
3. è¿‡ç¨‹å®æ¥æ”¶ TokenStream
   â†“
4. è¿‡ç¨‹å®ç”Ÿæˆæ–°çš„ TokenStream
   â†“
5. ç¼–è¯‘å™¨ç»§ç»­ç¼–è¯‘ç”Ÿæˆçš„ä»£ç 
```

### è¿‡ç¨‹å®çš„ç­¾å

```rust
// æ´¾ç”Ÿå®çš„ç­¾å
#[proc_macro_derive(MyDerive)]
pub fn my_derive(input: TokenStream) -> TokenStream {
    // input: è¾“å…¥çš„ä»£ç ï¼ˆå¦‚ç»“æ„ä½“å®šä¹‰ï¼‰
    // è¿”å›: ç”Ÿæˆçš„ä»£ç ï¼ˆå¦‚ trait å®ç°ï¼‰
}

// å±æ€§å®çš„ç­¾å
#[proc_macro_attribute]
pub fn my_attribute(attr: TokenStream, item: TokenStream) -> TokenStream {
    // attr: å±æ€§çš„å‚æ•°
    // item: è¢«ä¿®é¥°çš„é¡¹
    // è¿”å›: ä¿®æ”¹åçš„ä»£ç 
}

// å‡½æ•°å¼å®çš„ç­¾å
#[proc_macro]
pub fn my_macro(input: TokenStream) -> TokenStream {
    // input: å®è°ƒç”¨æ—¶ä¼ å…¥çš„ä»£ç 
    // è¿”å›: ç”Ÿæˆçš„ä»£ç 
}
```

---

## åˆ›å»ºè‡ªå®šä¹‰è¿‡ç¨‹å®

### é¡¹ç›®ç»“æ„

```toml
# Cargo.toml
[package]
name = "my_macro"
version = "0.1.0"
edition = "2021"

[lib]
proc-macro = true  # å¿…é¡»ï¼æ ‡è®°è¿™æ˜¯è¿‡ç¨‹å®åº“

[dependencies]
syn = "2.0"        # è§£æ Rust ä»£ç 
quote = "1.0"      # ç”Ÿæˆ Rust ä»£ç 
proc-macro2 = "1.0"
```

### ä¾‹å­ 1ï¼šç®€å•çš„æ´¾ç”Ÿå®

```rust
// my_macro/src/lib.rs
use proc_macro::TokenStream;
use quote::quote;
use syn::{parse_macro_input, DeriveInput};

// å®šä¹‰ä¸€ä¸ªæ´¾ç”Ÿå® HelloMacro
#[proc_macro_derive(HelloMacro)]
pub fn hello_macro_derive(input: TokenStream) -> TokenStream {
    // è§£æè¾“å…¥
    let input = parse_macro_input!(input as DeriveInput);
    let name = &input.ident;  // è·å–ç»“æ„ä½“åç§°
    
    // ç”Ÿæˆä»£ç 
    let expanded = quote! {
        impl HelloMacro for #name {
            fn hello() {
                println!("Hello from {}!", stringify!(#name));
            }
        }
    };
    
    // è¿”å›ç”Ÿæˆçš„ä»£ç 
    TokenStream::from(expanded)
}
```

**ä½¿ç”¨è‡ªå®šä¹‰å®**ï¼š
```rust
// åœ¨å¦ä¸€ä¸ªé¡¹ç›®ä¸­
use my_macro::HelloMacro;

trait HelloMacro {
    fn hello();
}

#[derive(HelloMacro)]
struct Person;

#[derive(HelloMacro)]
struct Robot;

fn main() {
    Person::hello();  // è¾“å‡º: Hello from Person!
    Robot::hello();   // è¾“å‡º: Hello from Robot!
}
```

### ä¾‹å­ 2ï¼šå±æ€§å® - æ€§èƒ½è®¡æ—¶

```rust
use proc_macro::TokenStream;
use quote::quote;
use syn::{parse_macro_input, ItemFn};

#[proc_macro_attribute]
pub fn timing(_attr: TokenStream, item: TokenStream) -> TokenStream {
    let input_fn = parse_macro_input!(item as ItemFn);
    let fn_name = &input_fn.sig.ident;
    let fn_block = &input_fn.block;
    let fn_sig = &input_fn.sig;
    let fn_vis = &input_fn.vis;
    
    let expanded = quote! {
        #fn_vis #fn_sig {
            let start = std::time::Instant::now();
            let result = (|| #fn_block)();
            let duration = start.elapsed();
            println!("{} æ‰§è¡Œæ—¶é—´: {:?}", stringify!(#fn_name), duration);
            result
        }
    };
    
    TokenStream::from(expanded)
}
```

**ä½¿ç”¨**ï¼š
```rust
#[timing]
fn slow_function() {
    std::thread::sleep(std::time::Duration::from_secs(1));
    println!("å®Œæˆï¼");
}

fn main() {
    slow_function();
    // è¾“å‡º:
    // å®Œæˆï¼
    // slow_function æ‰§è¡Œæ—¶é—´: 1.00s
}
```

### ä¾‹å­ 3ï¼šå‡½æ•°å¼å® - SQL éªŒè¯

```rust
use proc_macro::TokenStream;
use quote::quote;

#[proc_macro]
pub fn sql(input: TokenStream) -> TokenStream {
    let sql_query = input.to_string();
    
    // åœ¨ç¼–è¯‘æ—¶éªŒè¯ SQL è¯­æ³•
    if !sql_query.to_uppercase().contains("SELECT") {
        panic!("æ— æ•ˆçš„ SQL æŸ¥è¯¢ï¼");
    }
    
    // ç”Ÿæˆä»£ç 
    let expanded = quote! {
        String::from(#sql_query)
    };
    
    TokenStream::from(expanded)
}
```

**ä½¿ç”¨**ï¼š
```rust
fn main() {
    let query = sql!("SELECT * FROM users");  // âœ… ç¼–è¯‘é€šè¿‡
    // let bad = sql!("INVALID SQL");         // âŒ ç¼–è¯‘é”™è¯¯
}
```

---

## å¸¸è§çš„è¿‡ç¨‹å®åº“

### 1. Serde - åºåˆ—åŒ–/ååºåˆ—åŒ–

```rust
use serde::{Serialize, Deserialize};

#[derive(Serialize, Deserialize)]
struct Config {
    name: String,
    version: String,
}
```

### 2. Tokio - å¼‚æ­¥è¿è¡Œæ—¶

```rust
#[tokio::main]
async fn main() {
    // å¼‚æ­¥ä»£ç 
}

#[tokio::test]
async fn test_async() {
    // å¼‚æ­¥æµ‹è¯•
}
```

### 3. Diesel - ORM

```rust
#[derive(Queryable)]
struct User {
    id: i32,
    name: String,
}

table! {
    users (id) {
        id -> Integer,
        name -> Text,
    }
}
```

### 4. Actix-web - Web æ¡†æ¶

```rust
#[get("/")]
async fn index() -> impl Responder {
    HttpResponse::Ok().body("Hello!")
}

#[post("/users")]
async fn create_user(user: web::Json<User>) -> impl Responder {
    // ...
}
```

### 5. Thiserror - é”™è¯¯å¤„ç†

```rust
use thiserror::Error;

#[derive(Error, Debug)]
pub enum MyError {
    #[error("æ–‡ä»¶æœªæ‰¾åˆ°: {path}")]
    NotFound { path: String },
    
    #[error("IO é”™è¯¯")]
    Io(#[from] std::io::Error),
}
```

---

## è¿‡ç¨‹å® vs å£°æ˜å®

| ç‰¹æ€§ | å£°æ˜å® | è¿‡ç¨‹å® |
|------|--------|--------|
| **å®šä¹‰æ–¹å¼** | `macro_rules!` | Rust å‡½æ•° + ç‰¹æ®Šå±æ€§ |
| **åŠŸèƒ½** | åŸºäºæ¨¡å¼åŒ¹é… | å¯ä»¥ä»»æ„å¤„ç†ä»£ç  |
| **å¤æ‚åº¦** | ç®€å• | å¤æ‚ä½†å¼ºå¤§ |
| **ç¼–è¯‘æ—¶é—´** | å¿« | è¾ƒæ…¢ |
| **é”™è¯¯ä¿¡æ¯** | è¾ƒå·® | è¾ƒå¥½ |
| **ä½¿ç”¨åœºæ™¯** | ç®€å•é‡å¤ä»£ç  | å¤æ‚ä»£ç ç”Ÿæˆ |

**å£°æ˜å®ä¾‹å­**ï¼š
```rust
macro_rules! say_hello {
    () => {
        println!("Hello!");
    };
}
```

**è¿‡ç¨‹å®ä¾‹å­**ï¼š
```rust
#[derive(Debug)]  // å¯ä»¥æ£€æŸ¥ç»“æ„ä½“å®šä¹‰ï¼Œç”Ÿæˆå¤æ‚ä»£ç 
struct Point { x: i32, y: i32 }
```

---

## è¿‡ç¨‹å®çš„ä¼˜ç¼ºç‚¹

### âœ… ä¼˜ç‚¹

1. **å‡å°‘æ ·æ¿ä»£ç **
```rust
// ä¸ç”¨å†™
impl Debug for User { /* å¾ˆå¤šä»£ç  */ }
impl Clone for User { /* å¾ˆå¤šä»£ç  */ }

// åªéœ€å†™
#[derive(Debug, Clone)]
struct User { /* ... */ }
```

2. **ç¼–è¯‘æ—¶ä»£ç ç”Ÿæˆ**
```rust
// åœ¨ç¼–è¯‘æ—¶å°±ç”Ÿæˆä¼˜åŒ–çš„ä»£ç 
#[derive(Serialize)]
struct Data { /* ... */ }
```

3. **ç±»å‹å®‰å…¨**
```rust
// å®å¯ä»¥æ£€æŸ¥ç±»å‹ï¼Œæä¾›ç¼–è¯‘æ—¶ä¿è¯
sql!("SELECT * FROM users");  // ç¼–è¯‘æ—¶éªŒè¯
```

4. **é›¶è¿è¡Œæ—¶å¼€é”€**
- æ‰€æœ‰ä»£ç åœ¨ç¼–è¯‘æ—¶ç”Ÿæˆ
- æ²¡æœ‰åå°„çš„æ€§èƒ½æŸè€—

### âŒ ç¼ºç‚¹

1. **ç¼–è¯‘æ—¶é—´å¢åŠ **
- å¤§é‡ä½¿ç”¨è¿‡ç¨‹å®ä¼šæ˜¾è‘—å¢åŠ ç¼–è¯‘æ—¶é—´

2. **è°ƒè¯•å›°éš¾**
- ç”Ÿæˆçš„ä»£ç ä¸å¯è§
- é”™è¯¯ä¿¡æ¯å¯èƒ½ä¸æ¸…æ™°

3. **å­¦ä¹ æ›²çº¿é™¡å³­**
- éœ€è¦ç†è§£ `syn`, `quote` ç­‰åº“
- éœ€è¦ç†è§£ TokenStream

4. **IDE æ”¯æŒæœ‰é™**
- è‡ªåŠ¨è¡¥å…¨å¯èƒ½ä¸å®Œæ•´
- è·³è½¬å®šä¹‰å¯èƒ½ä¸å‡†ç¡®

---

## è°ƒè¯•è¿‡ç¨‹å®

### 1. ä½¿ç”¨ `cargo expand`

```bash
# å®‰è£…
cargo install cargo-expand

# æŸ¥çœ‹å®å±•å¼€åçš„ä»£ç 
cargo expand

# æŸ¥çœ‹ç‰¹å®šæ¨¡å—
cargo expand module_name
```

**ä¾‹å­**ï¼š
```rust
#[derive(Debug)]
struct Point { x: i32, y: i32 }

// cargo expand åçœ‹åˆ°ï¼š
impl std::fmt::Debug for Point {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        f.debug_struct("Point")
            .field("x", &self.x)
            .field("y", &self.y)
            .finish()
    }
}
```

### 2. ä½¿ç”¨ `eprintln!` è°ƒè¯•

```rust
#[proc_macro_derive(MyMacro)]
pub fn my_macro(input: TokenStream) -> TokenStream {
    // æ‰“å°è¾“å…¥
    eprintln!("è¾“å…¥: {}", input);
    
    let parsed = parse_macro_input!(input as DeriveInput);
    eprintln!("è§£æå: {:?}", parsed);
    
    // ...
}
```

---

## æœ€ä½³å®è·µ

### 1. âœ… ä¸ºå¤æ‚åœºæ™¯ä½¿ç”¨è¿‡ç¨‹å®

```rust
// âœ… å¥½çš„ä½¿ç”¨åœºæ™¯
#[derive(Serialize, Deserialize)]  // ç”Ÿæˆå¤æ‚çš„åºåˆ—åŒ–ä»£ç 
struct Config { /* ... */ }
```

### 2. âŒ ä¸è¦è¿‡åº¦ä½¿ç”¨

```rust
// âŒ ç®€å•çš„æƒ…å†µä¸éœ€è¦å®
// ä¸å…¶å†™ä¸€ä¸ªå®ï¼Œä¸å¦‚ç›´æ¥å†™å‡½æ•°
fn greet(name: &str) {
    println!("Hello, {}!", name);
}
```

### 3. âœ… æä¾›æ¸…æ™°çš„é”™è¯¯ä¿¡æ¯

```rust
#[proc_macro_derive(MyMacro)]
pub fn my_macro(input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as DeriveInput);
    
    // âœ… å¥½çš„é”™è¯¯ä¿¡æ¯
    if input.generics.params.is_empty() {
        return syn::Error::new(
            input.ident.span(),
            "MyMacro åªèƒ½ç”¨äºæ³›å‹ç±»å‹"
        ).to_compile_error().into();
    }
    
    // ...
}
```

### 4. âœ… ç¼–å†™æµ‹è¯•

```rust
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_macro() {
        let input = quote! {
            struct Test { field: i32 }
        };
        let output = my_macro(input.into());
        // éªŒè¯è¾“å‡º
    }
}
```

---

## æ€»ç»“

**è¿‡ç¨‹å®**æ˜¯ Rust ä¸­å¼ºå¤§çš„å…ƒç¼–ç¨‹å·¥å…·ï¼š

1. **ä¸‰ç§ç±»å‹**ï¼š
   - æ´¾ç”Ÿå® `#[derive(...)]`
   - å±æ€§å® `#[attr]`
   - å‡½æ•°å¼å® `macro!(...)`

2. **æ ¸å¿ƒæ¦‚å¿µ**ï¼š
   - åœ¨ç¼–è¯‘æ—¶å¤„ç†ä»£ç 
   - è¾“å…¥å’Œè¾“å‡ºéƒ½æ˜¯ `TokenStream`
   - å¯ä»¥ç”Ÿæˆä»»æ„ Rust ä»£ç 

3. **å¸¸è§ç”¨é€”**ï¼š
   - è‡ªåŠ¨å®ç° traitï¼ˆDebug, Serialize ç­‰ï¼‰
   - å‡å°‘æ ·æ¿ä»£ç 
   - ç¼–è¯‘æ—¶éªŒè¯
   - DSLï¼ˆé¢†åŸŸç‰¹å®šè¯­è¨€ï¼‰

4. **æƒè¡¡**ï¼š
   - âœ… å¼ºå¤§ã€ç±»å‹å®‰å…¨ã€é›¶è¿è¡Œæ—¶å¼€é”€
   - âŒ å¢åŠ ç¼–è¯‘æ—¶é—´ã€è°ƒè¯•å›°éš¾

è¿‡ç¨‹å®è®© Rust çš„è¡¨è¾¾èƒ½åŠ›å¤§å¤§å¢å¼ºï¼Œä½†è¦é€‚åº¦ä½¿ç”¨ï¼ğŸ¦€

---

## å‚è€ƒèµ„æº

- [The Rust Book - Macros](https://doc.rust-lang.org/book/ch19-06-macros.html)
- [Procedural Macros Workshop](https://github.com/dtolnay/proc-macro-workshop)
- [syn æ–‡æ¡£](https://docs.rs/syn/)
- [quote æ–‡æ¡£](https://docs.rs/quote/)

